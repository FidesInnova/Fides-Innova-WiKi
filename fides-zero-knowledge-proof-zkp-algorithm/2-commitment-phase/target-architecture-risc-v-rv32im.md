---
description: >-
  This phase requires a specific CPU architecture. In this page, we consider
  registers and instructions based on RISC-V RV32IM architecture.
---

# Target architecture - RISC-V RV32IM

## Registers

We support RISC-V32 registers:

<table><thead><tr><th width="164">ZKP Register</th><th width="264">RISC-V Register</th><th>Description</th></tr></thead><tbody><tr><td>x0</td><td>zero</td><td>Hardwired zero</td></tr><tr><td>x1</td><td>ra</td><td>Return address</td></tr><tr><td>x2</td><td>sp</td><td>Stack pointer</td></tr><tr><td>x3</td><td>gp</td><td>Global pointer</td></tr><tr><td>x4</td><td>tp</td><td>Thread pointer</td></tr><tr><td>x5</td><td>t0</td><td>Temporary register</td></tr><tr><td>x6</td><td>t1</td><td>Temporary register</td></tr><tr><td>x7</td><td>t2</td><td>Temporary register</td></tr><tr><td>x8</td><td>s0</td><td>Platform register</td></tr><tr><td>x9</td><td>s1</td><td>Platform register</td></tr><tr><td>x10</td><td>a0</td><td>Argument register</td></tr><tr><td>x11</td><td>a1</td><td>Argument register</td></tr><tr><td>x12</td><td>a2</td><td>Temporary register</td></tr><tr><td>x13</td><td>a3</td><td>Temporary register</td></tr><tr><td>x14</td><td>a4</td><td>Temporary register</td></tr><tr><td>x15</td><td>a5</td><td>Temporary register</td></tr><tr><td>x16</td><td>a6</td><td>Temporary register</td></tr><tr><td>x17</td><td>a7</td><td>Temporary register</td></tr><tr><td>x18</td><td>s2</td><td>Saved register</td></tr><tr><td>x19</td><td>s3</td><td>Saved register</td></tr><tr><td>x20</td><td>s4</td><td>Saved register</td></tr><tr><td>x21</td><td>s5</td><td>Saved register</td></tr><tr><td>x22</td><td>s6</td><td>Saved register</td></tr><tr><td>x23</td><td>s7</td><td>Saved register</td></tr><tr><td>x24</td><td>s8</td><td>Saved register</td></tr><tr><td>x25</td><td>s9</td><td>Saved register</td></tr><tr><td>x26</td><td>s10</td><td>Saved register</td></tr><tr><td>x27</td><td>s11</td><td>Saved register</td></tr><tr><td>x28</td><td>t3</td><td>Temporary register</td></tr><tr><td>x29</td><td>t4</td><td>Frame pointer</td></tr><tr><td>x30</td><td>t5</td><td>Return address</td></tr><tr><td>x31</td><td>t6</td><td>Integer register</td></tr></tbody></table>

## Instructions:

We support RISC-V32 instruction sets versions I and M:

<table><thead><tr><th width="131">Set RV32I</th><th width="800">Description</th></tr></thead><tbody><tr><td>LUI</td><td>Load Upper Immediate: Loads a 20-bit immediate value into the upper 20 bits of a register, zero-filling the lower 12 bits.</td></tr><tr><td>AUIPC</td><td>Add Upper Immediate to PC: Adds a 20-bit immediate value to the current program counter (PC), storing the result in a register. This is often used for generating global addresses.</td></tr><tr><td>JAL</td><td>Jump and Link: Performs an unconditional jump to a target address and saves the address of the next instruction (PC+4) in a register.</td></tr><tr><td>JALR</td><td>Jump and Link Register: Jumps to a target address specified in a register and saves the address of the next instruction (PC+4) in a register.</td></tr><tr><td>BEQ</td><td>Branch if Equal: Branches to a target address if two registers are equal.</td></tr><tr><td>BNE</td><td>Branch if Not Equal: Branches to a target address if two registers are not equal.</td></tr><tr><td>BLT</td><td>Branch if Less Than: Branches to a target address if one register is less than another.</td></tr><tr><td>BGE</td><td>Branch if Greater Than or Equal: Branches to a target address if one register is greater than or equal to another.</td></tr><tr><td>BLTU</td><td>Branch if Less Than Unsigned: Branches to a target address if one register is less than another (unsigned comparison).</td></tr><tr><td>BGEU</td><td>Branch if Greater Than or Equal Unsigned: Branches to a target address if one register is greater than or equal to another (unsigned comparison).</td></tr><tr><td>LB</td><td>Load Byte: Loads a signed byte from memory into a register.</td></tr><tr><td>LH</td><td>Load Halfword: Loads a signed halfword (2 bytes) from memory into a register.</td></tr><tr><td>LW</td><td>Load Word: Loads a word (4 bytes) from memory into a register.</td></tr><tr><td>LBU</td><td>Load Byte Unsigned: Loads an unsigned byte from memory into a register.</td></tr><tr><td>LHU</td><td>Load Halfword Unsigned: Loads an unsigned halfword from memory into a register.</td></tr><tr><td>SB</td><td>Store Byte: Stores the low 8 bits of a register into memory.</td></tr><tr><td>SH</td><td>Store Halfword: Stores the low 16 bits of a register into memory.</td></tr><tr><td>SW</td><td>Store Word: Stores the full 32 bits of a register into memory.</td></tr><tr><td>ADDI</td><td>Add Immediate: Adds an immediate value to a register and stores the result in a register.</td></tr><tr><td>SLTI</td><td>Set Less Than Immediate: Sets a register to 1 if it is less than an immediate value; otherwise, sets it to 0.</td></tr><tr><td>SLTIU</td><td>Set Less Than Immediate Unsigned: Sets a register to 1 if it is less than an immediate value (unsigned comparison); otherwise, sets it to 0.</td></tr><tr><td>XORI</td><td>XOR Immediate: Performs a bitwise XOR operation between a register and an immediate value, storing the result in a register.</td></tr><tr><td>ORI</td><td>OR Immediate: Performs a bitwise OR operation between a register and an immediate value, storing the result in a register.</td></tr><tr><td>ANDI</td><td>AND Immediate: Performs a bitwise AND operation between a register and an immediate value, storing the result in a register.</td></tr><tr><td>SLLI</td><td>Shift Left Logical Immediate: Shifts the bits in a register left by an immediate amount and stores the result in a register.</td></tr><tr><td>SRLI</td><td>Shift Right Logical Immediate: Shifts the bits in a register right by an immediate amount, filling with zeros, and stores the result in a register.</td></tr><tr><td>SRAI</td><td>Shift Right Arithmetic Immediate: Shifts the bits in a register right by an immediate amount, sign-extending the most significant bit, and stores the result in a register.</td></tr><tr><td>ADD</td><td>Addition: Adds two registers and stores the result in a third register.</td></tr><tr><td>SUB</td><td>Subtraction: Subtracts one register from another and stores the result in a third register.</td></tr><tr><td>SLL</td><td>Shift Left Logical: Shifts the bits in one register left by the number of bits specified in another register and stores the result in a third register.</td></tr><tr><td>SLT</td><td>Set Less Than: Sets a register to 1 if one register is less than another; otherwise, sets it to 0.</td></tr><tr><td>SLTU</td><td>Set Less Than Unsigned: Sets a register to 1 if one register is less than another (unsigned comparison); otherwise, sets it to 0.</td></tr><tr><td>XOR</td><td>XOR: Performs a bitwise XOR operation between two registers and stores the result in a third register.</td></tr><tr><td>OR</td><td>OR: Performs a bitwise OR operation between two registers and stores the result in a third register.</td></tr><tr><td>AND</td><td>AND: Performs a bitwise AND operation between two registers and stores the result in a third register.</td></tr></tbody></table>

<table><thead><tr><th width="119">Set M</th><th width="618">Description</th></tr></thead><tbody><tr><td>MUL</td><td>Multiply</td></tr><tr><td>MULH</td><td>Multiply High (signed)</td></tr><tr><td>MULHSU</td><td>Multiply High (signed)</td></tr><tr><td>MULHU</td><td>Multiply High (unsigned)</td></tr><tr><td>DIV</td><td>Divide</td></tr><tr><td>DIVU</td><td>Divide (unsigned)</td></tr><tr><td>REM</td><td>Remainder</td></tr><tr><td>REMU</td><td>Remainder (unsigned)</td></tr></tbody></table>

## Reference

\[1]. [https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf)&#x20;

\[2].[https://www.espressif.com/sites/default/files/documentation/esp32-c6\_technical\_reference\_manual\_en.pdf](https://www.espressif.com/sites/default/files/documentation/esp32-c6_technical_reference_manual_en.pdf)
